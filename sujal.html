<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sujal's Questions</title>
    <link rel="stylesheet" href="/collage_Assi/style.css">
</head>
<body>
    <div class="container">
        
        <!-- This links back to the MAIN team page -->
        <a href="/collage_Assi/index.html" class="back-link">&larr; Back to Team Page</a>
        
        <h1>Sujal's DSA Questions</h1>
        <p>Here are the 3 Binary Search problems I have solved.</p>
        
        <!-- --- Problem 1 --- -->
        <div class="problem-container">
            <h2>Problem 1: Standard Binary Search</h2>
            
            <h3>Problem Statement</h3>
            <p>Given a sorted array of integers `nums` and an integer `target`, write a function to search for `target` in `nums`. If `target` exists, return its index. Otherwise, return -1. You must write an algorithm with $O(\log n)$ runtime.</p>
            
            <h3>Approach</h3>
            <p>Use two pointers, `low` and `high`. Find the `mid` point. If `nums[mid]` is the target, return `mid`. If the target is larger, search the right half by setting `low = mid + 1`. If the target is smaller, search the left half by setting `high = mid - 1`.</p>
            
            <h3>Example</h3>
            <pre class="code-block">Input: nums = [-1, 0, 3, 5, 9, 12], target = 9
Output: 4</pre>
            
            <h3>Solution (Java)</h3>
            <pre class="code-block"><code>
class Solution {
    public int search(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return -1; // Target not found
    }
}
</code></pre>
        </div> <!-- End Problem 1 -->

        <!-- --- Problem 2 --- -->
        <div class="problem-container">
            <h2>Problem 2: Search Insert Position</h2>
            
            <h3>Problem Statement</h3>
            <p>Given a sorted array of distinct integers `nums` and a `target` value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.</p>
            
            <h3>Approach</h3>
            <p>This is a Binary Search variant. We perform a standard Binary Search. If the target is found, we return `mid`. If the loop finishes without finding the target, the `low` pointer will be at the exact position where the target should be inserted.</p>
            
            <h3>Example</h3>
            <pre class="code-block">Input: nums = [1, 3, 5, 6], target = 2
Output: 1</pre>
            
            <h3>Solution (Java)</h3>
            <pre class="code-block"><code>
class Solution {
    public int searchInsert(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        
        // If target is not found, 'low' is the insertion point
        return low;
    }
}
</code></pre>
        </div> <!-- End Problem 2 -->
        
        <!-- --- Problem 3 --- -->
        <div class="problem-container">
            <h2>Problem 3: First Bad Version</h2>
            
            <h3>Problem Statement</h3>
            <p>You have `n` versions `[1, ..., n]` and an API `bool isBadVersion(version)`. Find the first bad version, which causes all following ones to be bad. Minimize API calls.</p>
            
            <h3>Approach</h3>
            <p>This is a Binary Search problem on the "answer space" from 1 to `n`. We search for the *smallest* index that is `true`. If `isBadVersion(mid)` is `true`, we know the first bad version is at `mid` or to its left, so we set `high = mid`. If it's `false`, the first bad version must be to its right, so we set `low = mid + 1`.</p>
            
            <h3>Example</h3>
            <pre class="code-block">Input: n = 5, bad = 4
Output: 4</pre>
            
            <h3>Solution (Java)</h3>
            <pre class="code-block"><code>
/* The isBadVersion API is defined for you.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        int low = 1;
        int high = n;
        
        while (low < high) {
            int mid = low + (high - low) / 2;
            if (isBadVersion(mid)) {
                high = mid; // This could be the first, so check left
            } else {
                low = mid + 1; // It must be after this one
            }
        }
        
        return low; // 'low' and 'high' meet at the first bad version
    }
}
</code></pre>
        </div> <!-- End Problem 3 -->
        
    </div>
</body>
</html>