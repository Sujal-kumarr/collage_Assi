<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sahil's Questions</title>
    <link rel="stylesheet" href="/collage_Assi/style.css">
</head>
<body>
    <div class="container">
        
        <!-- This links back to the MAIN team page -->
        <a href="/collage_Assi/index.html" class="back-link">&larr; Back to Team Page</a>
        
        <h1>Sahil's DSA Questions</h1>
        <p>Here are the 3 Binary Search problems I have solved.</p>
        
        <!-- --- Problem 1 --- -->
        <div class="problem-container">
            <h2>Problem 1: Search in Rotated Sorted Array</h2>
            
            <h3>Problem Statement</h3>
            <p>An array `nums` sorted in ascending order is rotated at some pivot. Given `nums` and a `target`, return the index of `target` if it is in `nums`, or -1 otherwise. You must write an algorithm with $O(\log n)$ runtime.</p>
            
            <h3>Approach</h3>
            <p>Use a modified Binary Search. At each step, find `mid`. Check if the left half (from `low` to `mid`) is sorted. If it is, check if the target is within that range. If it is, search left (`high = mid - 1`). If not, search right (`low = mid + 1`). Do the same logic if the right half is sorted.</p>
            
            <h3>Example</h3>
            <pre class="code-block">Input: nums = [4, 5, 6, 7, 0, 1, 2], target = 0
Output: 4</pre>
            
            <h3>Solution (Java)</h3>
            <pre class="code-block"><code>
class Solution {
    public int search(int[] nums, int target) {
        int low = 0;
        int high = nums.length - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (nums[mid] == target) {
                return mid;
            }
            
            // Check if left half is sorted
            if (nums[low] <= nums[mid]) {
                if (target >= nums[low] && target < nums[mid]) {
                    high = mid - 1; // Target is in left half
                } else {
                    low = mid + 1;  // Target is in right half
                }
            } 
            // Right half must be sorted
            else {
                if (target > nums[mid] && target <= nums[high]) {
                    low = mid + 1;  // Target is in right half
                } else {
                    high = mid - 1; // Target is in left half
                }
            }
        }
        return -1; // Target not found
    }
}
</code></pre>
        </div> <!-- End Problem 1 -->

        <!-- --- Problem 2 --- -->
        <div class="problem-container">
            <h2>Problem 2: Find First and Last Position of Element</h2>
            
            <h3>Problem Statement</h3>
            <p>Given a sorted array `nums` and a `target`, find the starting and ending position of the target. If the target is not found, return `[-1, -1]`. You must write an algorithm with $O(\log n)$ runtime.</p>
            
            <h3>Approach</h3>
            <p>Run Binary Search twice. First, create a helper function `findBound` that searches for the target. When the target is found, if you are looking for the *first* position, you continue searching to the *left* (`high = mid - 1`). If you are looking for the *last* position, you continue searching to the *right* (`low = mid + 1`).</p>
            
            <h3>Example</h3>
            <pre class="code-block">Input: nums = [5, 7, 7, 8, 8, 10], target = 8
Output: [3, 4]</pre>
            
            <h3>Solution (Java)</h3>
            <pre class="code-block"><code>
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int first = findBound(nums, target, true);
        int last = findBound(nums, target, false);
        return new int[]{first, last};
    }
    
    private int findBound(int[] nums, int target, boolean isFirst) {
        int low = 0;
        int high = nums.length - 1;
        int result = -1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            if (nums[mid] == target) {
                result = mid; // Found a potential answer
                if (isFirst) {
                    high = mid - 1; // Keep searching left
                } else {
                    low = mid + 1;  // Keep searching right
                }
            } else if (nums[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return result;
    }
}
</code></pre>
        </div> <!-- End Problem 2 -->
        
        <!-- --- Problem 3 --- -->
        <div class="problem-container">
            <h2>Problem 3: Find Peak Element</h2>
            
            <h3>Problem Statement</h3>
            <p>A peak element is an element that is strictly greater than its neighbors. Given an integer array `nums`, find a peak element, and return its index. You may imagine that `nums[-1] = nums[n] = -âˆž`.</p>
            
            <h3>Approach</h3>
            <p>Use Binary Search. If `nums[mid]` is less than `nums[mid + 1]`, it means a peak must exist to the right, so we set `low = mid + 1`. If `nums[mid]` is greater than `nums[mid + 1]`, a peak must exist at `mid` or to its left, so we set `high = mid`. The loop `low < high` will converge on a peak element.</p>
            
            <h3>Example</h3>
            <pre class="code-block">Input: nums = [1, 2, 3, 1]
Output: 2
Explanation: 3 is a peak element and your function should return the index 2.</pre>
            
            <h3>Solution (Java)</h3>
            <pre class="code-block"><code>
class Solution {
    public int findPeakElement(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        
        while (low < high) {
            int mid = low + (high - low) / 2;
            
            if (nums[mid] < nums[mid + 1]) {
                // We are on the "uphill" slope, peak is to the right
                low = mid + 1;
            } else {
                // We are on the "downhill" slope, peak is at mid or to the left
                high = mid;
            }
        }
        
        // 'low' and 'high' converge at a peak
        return low;
    }
}
</code></pre>
        </div> <!-- End Problem 3 -->
        
    </div>
</body>
</html>