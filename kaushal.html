<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kaushal's Questions</title>
    <link rel="stylesheet" href="/collage_Assi/style.css">
</head>
<body>
    <div class="container">
        
        <!-- This links back to the MAIN team page -->
        <a href="/collage_Assi/index.html" class="back-link">&larr; Back to Team Page</a>
        
        <h1>Kaushal's DSA Questions</h1>
        <p>Here are the 3 Binary Search problems I have solved.</p>
        
        <!-- --- Problem 1 --- -->
        <div class="problem-container">
            <h2>Problem 1: Find Minimum in Rotated Sorted Array</h2>
            
            <h3>Problem Statement</h3>
            <p>Suppose an array of length `n` sorted in ascending order is rotated. Find the minimum element in this array. You must write an algorithm that runs in $O(\log n)$ time.</p>
            
            <h3>Approach</h3>
            <p>Use Binary Search. The minimum element is the only element that is smaller than its previous element (the "pivot"). We compare `nums[mid]` with `nums[high]`. If `mid` is smaller, the minimum must be at `mid` or to its left, so set `high = mid`. If `mid` is larger, the minimum must be to the right, so set `low = mid + 1`.</p>
            
            <h3>Example</h3>
            <pre class="code-block">Input: nums = [3, 4, 5, 1, 2]
Output: 1</pre>
            
            <h3>Solution (Java)</h3>
            <pre class="code-block"><code>
class Solution {
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;
        
        while (low < high) {
            int mid = low + (high - low) / 2;
            
            if (nums[mid] < nums[high]) {
                // The minimum is in the left half, or is 'mid'
                high = mid;
            } else {
                // The minimum is in the right half
                low = mid + 1;
            }
        }
        
        // The loop ends when low == high, which is the minimum element
        return nums[low];
    }
}
</code></pre>
        </div> <!-- End Problem 1 -->

        <!-- --- Problem 2 --- -->
        <div class="problem-container">
            <h2>Problem 2: Search a 2D Matrix</h2>
            
            <h3>Problem Statement</h3>
            <p>Write an efficient algorithm that searches for a value `target` in an `m x n` integer matrix. This matrix has two properties:
            1. Integers in each row are sorted from left to right.
            2. The first integer of each row is greater than the last integer of the previous row.</p>
            
            <h3>Approach</h3>
            <p>Treat the 2D matrix as a single, large sorted 1D array. The total number of elements is `m * n`. We can Binary Search on the indices from `0` to `(m * n) - 1`. For any `mid` index, we can find its 2D coordinates: `row = mid / n` and `col = mid % n`. Then we compare `matrix[row][col]` with the target.</p>
            
            <h3>Example</h3>
            <pre class="code-block">Input: matrix = [[1, 3, 5, 7], [10, 11, 16, 20], [23, 30, 34, 60]], target = 3
Output: true</pre>
            
            <h3>Solution (Java)</h3>
            <pre class="code-block"><code>
class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix.length == 0) return false;
        
        int rows = matrix.length;
        int cols = matrix[0].length;
        int low = 0;
        int high = (rows * cols) - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            
            // Convert 1D 'mid' index back to 2D
            int row = mid / cols;
            int col = mid % cols;
            
            int midValue = matrix[row][col];
            
            if (midValue == target) {
                return true;
            } else if (midValue < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return false;
    }
}
</code></pre>
        </div> <!-- End Problem 2 -->
        
        <!-- --- Problem 3 --- -->
        <div class="problem-container">
            <h2>Problem 3: Sqrt(x) - Find Square Root</h2>
            
            <h3>Problem Statement</h3>
            <p>Given a non-negative integer `x`, compute and return the square root of `x`. Since the return type is an integer, you should truncate the decimal digits, and only return the integer part.</p>
            
            <h3>Approach</h3>
            <p>Binary Search for the answer in the range from `1` to `x`. Pick a `mid` value. If `mid * mid` is exactly `x`, return `mid`. If `mid * mid` is *less than* `x`, then `mid` is a possible answer, so we store it and search the right half (`low = mid + 1`). If `mid * mid` is *greater than* `x`, it's too big, so we search the left half (`high = mid - 1`).</p>
            
            <h3>Example</h3>
            <pre class="code-block">Input: x = 8
Output: 2
Explanation: The square root of 8 is 2.828..., and since we truncate, 2 is returned.</pre>
            
            <h3>Solution (Java)</h3>
            <pre class="code-block"><code>
class Solution {
    public int mySqrt(int x) {
        if (x < 2) return x;
        
        long low = 1;
        long high = x / 2; // Optimization: sqrt(x) can't be more than x/2
        long result = 0;
        
        while (low <= high) {
            long mid = low + (high - low) / 2;
            long square = mid * mid;
            
            if (square == x) {
                return (int)mid;
            } else if (square < x) {
                result = mid; // This is a possible answer
                low = mid + 1; // Try for a larger one
            } else {
                high = mid - 1; // Too big, search left
            }
        }
        
        return (int)result; // Return the last valid 'possible' answer
    }
}
</code></pre>
        </div> <!-- End Problem 3 -->
        
    </div>
</body>
</html>